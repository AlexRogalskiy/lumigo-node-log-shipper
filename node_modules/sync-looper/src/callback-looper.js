const { MaximumRepetitionsError } = require("./errors");

/**
 * Wait until an error-first callback function returns results or exit in time had passed or exception was thrown.
 */
class CallbackLooper {
	constructor() {
		this.repetition = 0;
	}

	/**
	 * Wait until function returns results or exit in time had passed or exception was thrown.
	 * @param asyncIterator {function} Run this function over and over
	 * @param ms {number} Initial time to wait. Pay attention that exponential backoff is used here, e.g. ms * i for each repetition until maxRepetitions have reached.
	 * @param maxRepetitions {number} How many repetition to run
	 */
	arithmeticWait(iterator, ms, maxRepetitions, callback) {
		const msIntervals = [];
		for (let i = 1; i <= maxRepetitions; i++) {
			msIntervals.push(ms * i);
		}
		return this.waitForData(iterator, msIntervals, callback);
	}

	/**
	 * Wait until function returns results or exit in time had passed or exception was thrown.
	 * @param asyncIterator {function} Run this function over and over
	 * @param ms {number} Initial time to wait. Pay attention that exponential backoff is used here, e.g. ms * Math.pow(2, i) for each repetition until maxRepetitions have reached.
	 * @param maxRepetitions {number} How many repetition to run
	 */
	exponentialWait(iterator, ms, maxRepetitions, callback) {
		const msIntervals = [];
		for (let i = 0; i < maxRepetitions; i++) {
			msIntervals.push(ms * Math.pow(2, i));
		}
		return this.waitForData(iterator, msIntervals, callback);
	}

	/**
	 * Wait until function returns results or exit in time had passed or exception was thrown.
	 * @param asyncIterator {function} Run this function over and over
	 * @param ms {number} the time in milliseconds to wait until the next repetitions.
	 * @param maxRepetitions {number} How many repetition to run
	 */
	constWait(iterator, ms, maxRepetitions, callback) {
		const msIntervals = [];
		for (let i = 0; i < maxRepetitions; i++) {
			msIntervals.push(ms);
		}
		return this.waitForData(iterator, msIntervals, callback);
	}

	/**
	 * Wait until function returns results or exit in time had passed or exception was thrown.
	 * @param asyncIterator {function} Run this function over and over
	 * @param msIntervals {array} Intervals of time in milliseconds to wait until the next repetitions.
	 */
	waitForData(iterator, msIntervals, callback) {
		let repetition = 0;
		const _this = this;
		const loop = repetition => {
			iterator.call(_this, repetition, (err, data) => {
				if (err) return callback(err);
				if (data) {
					return callback(null, data);
				}
				if (repetition < msIntervals.length) {
					const ms = msIntervals[repetition];
					repetition++;
					setTimeout(() => {
						loop(repetition);
					}, ms);
				} else {
					callback(
						new MaximumRepetitionsError(
							"sync loop reached maximum repetitions",
							loop.repetition
						)
					);
				}
			});
		};
		loop(repetition);
	}
}

module.exports = CallbackLooper;
