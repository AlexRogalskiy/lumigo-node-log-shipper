const { MaximumRepetitionsError } = require("./errors");

const { promisify } = require("util");

/**
 * Use async, await with setTimeout
 */
const sleep = promisify(setTimeout);

/**
 * Wait until an async function returns results or exit in time had passed or exception was thrown.
 */
class AsyncLooper {
	constructor() {

	}

	/**
     * Wait until function returns results or exit in time had passed or exception was thrown.
     * @param asyncIterator {function} Run this function over and over
     * @param ms {number} Initial time to wait. Pay attention that exponential backoff is used here, e.g. ms * i for each repetition until maxRepetitions have reached.
     * @param maxRepetitions {number} How many repetition to run
     * @returns {Promise<*>}
     */
	async arithmeticWait(asyncIterator, ms, maxRepetitions) {
		const msIntervals = [];
		for (let i = 1; i <= maxRepetitions; i++){
			msIntervals.push(ms * i);
		}
		return await this.waitForData(asyncIterator, msIntervals);
	}

	/**
     * Wait until function returns results or exit in time had passed or exception was thrown.
     * @param asyncIterator {function} Run this function over and over
     * @param ms {number} Initial time to wait. Pay attention that exponential backoff is used here, e.g. ms * Math.pow(2, i) for each repetition until maxRepetitions have reached.
     * @param maxRepetitions {number} How many repetition to run
     * @returns {Promise<*>}
     */
	async exponentialWait(asyncIterator, ms, maxRepetitions) {
		const msIntervals = [];
		for (let i = 0; i < maxRepetitions; i++){
			msIntervals.push(ms * Math.pow(2, i));
		}
		return await this.waitForData(asyncIterator, msIntervals);
	}

	/**
     * Wait until function returns results or exit in time had passed or exception was thrown.
     * @param asyncIterator {function} Run this function over and over
     * @param ms {number} the time in milliseconds to wait until the next repetitions.
     * @param maxRepetitions {number} How many repetition to run
     * @returns {Promise<*>}
     */
	async constWait(asyncIterator, ms, maxRepetitions) {
		const msIntervals = [];
		for (let i = 0; i < maxRepetitions; i++){
			msIntervals.push(ms);
		}
		return await this.waitForData(asyncIterator, msIntervals);
	}

	/**
     * Wait until function returns results or exit in time had passed or exception was thrown.
     * @param asyncIterator {function} Run this function over and over
     * @param msIntervals {array} Intervals of time in milliseconds to wait until the next repetitions.
     * @returns {Promise<*>}
     */
	async waitForData(asyncIterator, msIntervals) {
		let exit = false;
		let repCount = 0;
		let sleepTime;
		while (!exit) {
			const data = await asyncIterator(repCount);
			if (data) return data;

			sleepTime = msIntervals[repCount];
			repCount++;
			exit = repCount > msIntervals.length;
			await sleep(sleepTime);
		}

		throw new MaximumRepetitionsError(
            `Wait is over for ${asyncIterator.name}. No valid results retrieved`,
            repCount
		);
	}
}

module.exports = AsyncLooper;